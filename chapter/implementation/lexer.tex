\subsection{Lexer}
The first part of a code generator is the lexer. A lexer gets a file or in this case a string as input and divides this input into a series of tokens. So the input \lstinline[language=sql]$@contains:apple:$ becomes the tokens: '@', 'contains', ':', 'apple' and ':'. These tokens are not interpreted yet but are only being recognized as separate characters. To achieve this in code the crate logos is used, to avoid writing redundant code. To understand the code written in lexer.rs what follows is a short explanation of how this crate is used in the context of this prototype.\\
To define tokens, Logos can be added to the derive statement of an enumeration and a matching rule can be defined using a literal string or a regular expression. For example, in line 73 of code listing \ref{code:tokens}, a literal string is used to recognize the colon token, and line 33 uses a regular expression to recognize decimals between 0 and 1. It also calls an arbitrary function to\_float (code \ref{code:tokens}, 17-19) to define that in this case the data should be cast into the datatype f64. Logos also requires an error type (code \ref{code:tokens}, 78-80), which is also used to skip whitespaces \parencite[cf.][n.p.]{noauthor_3_nodate}.
\begin{codeenv}
    \captionof{mycapcode}{Token defintions}
    \label{code:tokens}
    \lstinputlisting[language=java, linerange={16-19}]{code/bonicheckprototype/src/main/java/de/telekom/bonicheckprototype/configuration/AppConfiguration.java}
    \vdots
    \lstinputlisting[language=java, linerange={26-28}]{code/bonicheckprototype/src/main/java/de/telekom/bonicheckprototype/configuration/AppConfiguration.java}
    \centerline{Source: AppConfiguration.java}
\end{codeenv}
These tokens are then compiled in a list and passed over to the parser as the work of the lexer is done.
